[
  {
    "priority": "immediate",
    "module": "beneficiaries",
    "actions": [
      {
        "type": "move_code",
        "description": "Resolver acoplamento: Routes contém lógica de negócio ou acesso a dados",
        "target": "server/modules/beneficiaries/routes.ts",
        "steps": [
          "Identificar código acoplado",
          "Determinar camada correta para o código",
          "Mover código para camada apropriada",
          "Criar interfaces para comunicação entre camadas",
          "Atualizar dependências"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada domain",
        "target": "server/modules/beneficiaries/domain/services/BeneficiaryDomainService.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada application",
        "target": "server/modules/beneficiaries/application/controllers/BeneficiaryController.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "move_code",
        "description": "Resolver acoplamento: Entity misturada com DTOs - violação de responsabilidade",
        "target": "server/modules/beneficiaries/domain/entities/Beneficiary.ts",
        "steps": [
          "Identificar código acoplado",
          "Determinar camada correta para o código",
          "Mover código para camada apropriada",
          "Criar interfaces para comunicação entre camadas",
          "Atualizar dependências"
        ]
      },
      {
        "type": "rename_file",
        "description": "Padronizar nomenclatura: Use Case index deve terminar com 'UseCase'",
        "target": "server/modules/beneficiaries/application/use-cases/index.ts",
        "steps": [
          "Renomear arquivo seguindo padrão",
          "Atualizar imports em outros arquivos",
          "Atualizar nome da classe/interface",
          "Verificar consistência com padrões do projeto"
        ]
      }
    ],
    "estimatedTime": "4h"
  },
  {
    "priority": "immediate",
    "module": "knowledge-base",
    "actions": [
      {
        "type": "move_code",
        "description": "Resolver acoplamento: Routes contém lógica de negócio ou acesso a dados",
        "target": "server/modules/knowledge-base/routes.ts",
        "steps": [
          "Identificar código acoplado",
          "Determinar camada correta para o código",
          "Mover código para camada apropriada",
          "Criar interfaces para comunicação entre camadas",
          "Atualizar dependências"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada domain",
        "target": "server/modules/knowledge-base/domain/ports/IKnowledgeBaseEntryRepository.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada domain",
        "target": "server/modules/knowledge-base/domain/ports/IMediaRepository.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada application",
        "target": "server/modules/knowledge-base/application/controllers/KnowledgeBaseController.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada application",
        "target": "server/modules/knowledge-base/application/controllers/MediaController.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada application",
        "target": "server/modules/knowledge-base/application/services/MediaService.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "move_code",
        "description": "Resolver acoplamento: Repository contém possível lógica de negócio",
        "target": "server/modules/knowledge-base/infrastructure/repositories/KnowledgeBaseRepository.ts",
        "steps": [
          "Identificar código acoplado",
          "Determinar camada correta para o código",
          "Mover código para camada apropriada",
          "Criar interfaces para comunicação entre camadas",
          "Atualizar dependências"
        ]
      },
      {
        "type": "move_code",
        "description": "Resolver acoplamento: Repository contém possível lógica de negócio",
        "target": "server/modules/knowledge-base/infrastructure/repositories/MediaRepository.ts",
        "steps": [
          "Identificar código acoplado",
          "Determinar camada correta para o código",
          "Mover código para camada apropriada",
          "Criar interfaces para comunicação entre camadas",
          "Atualizar dependências"
        ]
      },
      {
        "type": "create_directory",
        "description": "Criar interface I[Entity]Repository no domain e implementar",
        "target": "server/modules/knowledge-base/infrastructure/repositories/KnowledgeBaseRepository.ts",
        "steps": [
          "Criar interface I[Entity]Repository no domain e implementar"
        ]
      },
      {
        "type": "create_directory",
        "description": "Criar interface I[Entity]Repository no domain e implementar",
        "target": "server/modules/knowledge-base/infrastructure/repositories/MediaRepository.ts",
        "steps": [
          "Criar interface I[Entity]Repository no domain e implementar"
        ]
      }
    ],
    "estimatedTime": "8h"
  },
  {
    "priority": "immediate",
    "module": "materials-services",
    "actions": [
      {
        "type": "move_code",
        "description": "Resolver acoplamento: Routes contém lógica de negócio ou acesso a dados",
        "target": "server/modules/materials-services/routes.ts",
        "steps": [
          "Identificar código acoplado",
          "Determinar camada correta para o código",
          "Mover código para camada apropriada",
          "Criar interfaces para comunicação entre camadas",
          "Atualizar dependências"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada domain",
        "target": "server/modules/materials-services/domain/ports/IAssetManagementRepository.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada domain",
        "target": "server/modules/materials-services/domain/ports/IComplianceRepository.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada domain",
        "target": "server/modules/materials-services/domain/ports/IItemRepository.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada domain",
        "target": "server/modules/materials-services/domain/ports/ILPUCacheWarmer.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada domain",
        "target": "server/modules/materials-services/domain/ports/ILPURepository.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada domain",
        "target": "server/modules/materials-services/domain/ports/IStockRepository.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada domain",
        "target": "server/modules/materials-services/domain/ports/ISupplierRepository.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada domain",
        "target": "server/modules/materials-services/domain/ports/IindexRepository.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada application",
        "target": "server/modules/materials-services/application/controllers/AssetManagementController.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada application",
        "target": "server/modules/materials-services/application/controllers/AuditController.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada application",
        "target": "server/modules/materials-services/application/controllers/ComplianceController.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada application",
        "target": "server/modules/materials-services/application/controllers/CustomerItemMappingController-fixed.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada application",
        "target": "server/modules/materials-services/application/controllers/CustomerItemMappingController-v2.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada application",
        "target": "server/modules/materials-services/application/controllers/CustomerItemMappingController.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada application",
        "target": "server/modules/materials-services/application/controllers/CustomerPersonalizationController.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada application",
        "target": "server/modules/materials-services/application/controllers/ImportController.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada application",
        "target": "server/modules/materials-services/application/controllers/ItemController.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada application",
        "target": "server/modules/materials-services/application/controllers/LPUController.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada application",
        "target": "server/modules/materials-services/application/controllers/PersonalizationController.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada application",
        "target": "server/modules/materials-services/application/controllers/StockController.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada application",
        "target": "server/modules/materials-services/application/controllers/SupplierController.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada application",
        "target": "server/modules/materials-services/application/controllers/SupplierLinksController.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada application",
        "target": "server/modules/materials-services/application/controllers/TicketMaterialsController.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada application",
        "target": "server/modules/materials-services/application/services/PricingRulesEngine.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "move_code",
        "description": "Resolver acoplamento: Repository contém possível lógica de negócio",
        "target": "server/modules/materials-services/infrastructure/repositories/ComplianceRepository.ts",
        "steps": [
          "Identificar código acoplado",
          "Determinar camada correta para o código",
          "Mover código para camada apropriada",
          "Criar interfaces para comunicação entre camadas",
          "Atualizar dependências"
        ]
      },
      {
        "type": "move_code",
        "description": "Resolver acoplamento: Repository contém possível lógica de negócio",
        "target": "server/modules/materials-services/infrastructure/repositories/ItemRepository.ts",
        "steps": [
          "Identificar código acoplado",
          "Determinar camada correta para o código",
          "Mover código para camada apropriada",
          "Criar interfaces para comunicação entre camadas",
          "Atualizar dependências"
        ]
      },
      {
        "type": "move_code",
        "description": "Resolver acoplamento: Repository contém possível lógica de negócio",
        "target": "server/modules/materials-services/infrastructure/repositories/LPUCacheWarmerRepository.ts",
        "steps": [
          "Identificar código acoplado",
          "Determinar camada correta para o código",
          "Mover código para camada apropriada",
          "Criar interfaces para comunicação entre camadas",
          "Atualizar dependências"
        ]
      },
      {
        "type": "move_code",
        "description": "Resolver acoplamento: Repository contém possível lógica de negócio",
        "target": "server/modules/materials-services/infrastructure/repositories/LPURepository.ts",
        "steps": [
          "Identificar código acoplado",
          "Determinar camada correta para o código",
          "Mover código para camada apropriada",
          "Criar interfaces para comunicação entre camadas",
          "Atualizar dependências"
        ]
      },
      {
        "type": "rename_file",
        "description": "Padronizar nomenclatura: Entity index não segue padrão PascalCase",
        "target": "server/modules/materials-services/domain/entities/index.ts",
        "steps": [
          "Renomear arquivo seguindo padrão",
          "Atualizar imports em outros arquivos",
          "Atualizar nome da classe/interface",
          "Verificar consistência com padrões do projeto"
        ]
      },
      {
        "type": "create_directory",
        "description": "Criar interface I[Entity]Repository no domain e implementar",
        "target": "server/modules/materials-services/infrastructure/repositories/AssetManagementRepository.ts",
        "steps": [
          "Criar interface I[Entity]Repository no domain e implementar"
        ]
      },
      {
        "type": "create_directory",
        "description": "Criar interface I[Entity]Repository no domain e implementar",
        "target": "server/modules/materials-services/infrastructure/repositories/ComplianceRepository.ts",
        "steps": [
          "Criar interface I[Entity]Repository no domain e implementar"
        ]
      },
      {
        "type": "create_directory",
        "description": "Criar interface I[Entity]Repository no domain e implementar",
        "target": "server/modules/materials-services/infrastructure/repositories/ItemRepository.ts",
        "steps": [
          "Criar interface I[Entity]Repository no domain e implementar"
        ]
      },
      {
        "type": "create_directory",
        "description": "Criar interface I[Entity]Repository no domain e implementar",
        "target": "server/modules/materials-services/infrastructure/repositories/LPURepository.ts",
        "steps": [
          "Criar interface I[Entity]Repository no domain e implementar"
        ]
      },
      {
        "type": "create_directory",
        "description": "Criar interface I[Entity]Repository no domain e implementar",
        "target": "server/modules/materials-services/infrastructure/repositories/StockRepository.ts",
        "steps": [
          "Criar interface I[Entity]Repository no domain e implementar"
        ]
      },
      {
        "type": "create_directory",
        "description": "Criar interface I[Entity]Repository no domain e implementar",
        "target": "server/modules/materials-services/infrastructure/repositories/SupplierRepository.ts",
        "steps": [
          "Criar interface I[Entity]Repository no domain e implementar"
        ]
      },
      {
        "type": "create_file",
        "description": "Criar Repository com interface",
        "target": "server/modules/materials-services/domain/ports/ILPUCacheWarmerRepository.ts",
        "code": "import { ILPUCacheWarmer } from '../../domain/entities/ILPUCacheWarmer';\nimport { IILPUCacheWarmerRepository } from '../../domain/ports/IILPUCacheWarmerRepository';\nimport { drizzle } from 'drizzle-orm/neon-http';\nimport * as schema from '@shared/schema';\n\nexport class DrizzleILPUCacheWarmerRepository implements IILPUCacheWarmerRepository {\n  constructor(private readonly db: ReturnType<typeof drizzle>) {}\n\n  async findById(id: string, tenantId: string): Promise<ILPUCacheWarmer | null> {\n    // Implementar busca por ID\n    throw new Error('Method not implemented.');\n  }\n\n  async findAll(tenantId: string): Promise<ILPUCacheWarmer[]> {\n    // Implementar busca de todos\n    throw new Error('Method not implemented.');\n  }\n\n  async create(entity: ILPUCacheWarmer): Promise<ILPUCacheWarmer> {\n    // Implementar criação\n    throw new Error('Method not implemented.');\n  }\n\n  async update(id: string, entity: Partial<ILPUCacheWarmer>, tenantId: string): Promise<ILPUCacheWarmer | null> {\n    // Implementar atualização\n    throw new Error('Method not implemented.');\n  }\n\n  async delete(id: string, tenantId: string): Promise<boolean> {\n    // Implementar exclusão\n    throw new Error('Method not implemented.');\n  }\n}\n",
        "steps": [
          "Criar interface do Repository na camada Domain",
          "Implementar Repository na camada Infrastructure",
          "Adicionar injeção de dependência",
          "Integrar com Use Cases"
        ]
      }
    ],
    "estimatedTime": "30h"
  },
  {
    "priority": "immediate",
    "module": "saas-admin",
    "actions": [
      {
        "type": "move_code",
        "description": "Resolver acoplamento: Routes contém lógica de negócio ou acesso a dados",
        "target": "server/modules/saas-admin/routes.ts",
        "steps": [
          "Identificar código acoplado",
          "Determinar camada correta para o código",
          "Mover código para camada apropriada",
          "Criar interfaces para comunicação entre camadas",
          "Atualizar dependências"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada domain",
        "target": "server/modules/saas-admin/domain/ports/Iindex.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada application",
        "target": "server/modules/saas-admin/application/controllers/SaasAdminController.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "rename_file",
        "description": "Padronizar nomenclatura: Entity index não segue padrão PascalCase",
        "target": "server/modules/saas-admin/domain/entities/index.ts",
        "steps": [
          "Renomear arquivo seguindo padrão",
          "Atualizar imports em outros arquivos",
          "Atualizar nome da classe/interface",
          "Verificar consistência com padrões do projeto"
        ]
      },
      {
        "type": "create_directory",
        "description": "Criar interface I[Entity]Repository no domain e implementar",
        "target": "server/modules/saas-admin/infrastructure/repositories/indexRepository.ts",
        "steps": [
          "Criar interface I[Entity]Repository no domain e implementar"
        ]
      },
      {
        "type": "create_file",
        "description": "Criar Repository com interface",
        "target": "server/modules/saas-admin/domain/ports/IindexRepository.ts",
        "code": "import { Iindex } from '../../domain/entities/Iindex';\nimport { IIindexRepository } from '../../domain/ports/IIindexRepository';\nimport { drizzle } from 'drizzle-orm/neon-http';\nimport * as schema from '@shared/schema';\n\nexport class DrizzleIindexRepository implements IIindexRepository {\n  constructor(private readonly db: ReturnType<typeof drizzle>) {}\n\n  async findById(id: string, tenantId: string): Promise<Iindex | null> {\n    // Implementar busca por ID\n    throw new Error('Method not implemented.');\n  }\n\n  async findAll(tenantId: string): Promise<Iindex[]> {\n    // Implementar busca de todos\n    throw new Error('Method not implemented.');\n  }\n\n  async create(entity: Iindex): Promise<Iindex> {\n    // Implementar criação\n    throw new Error('Method not implemented.');\n  }\n\n  async update(id: string, entity: Partial<Iindex>, tenantId: string): Promise<Iindex | null> {\n    // Implementar atualização\n    throw new Error('Method not implemented.');\n  }\n\n  async delete(id: string, tenantId: string): Promise<boolean> {\n    // Implementar exclusão\n    throw new Error('Method not implemented.');\n  }\n}\n",
        "steps": [
          "Criar interface do Repository na camada Domain",
          "Implementar Repository na camada Infrastructure",
          "Adicionar injeção de dependência",
          "Integrar com Use Cases"
        ]
      }
    ],
    "estimatedTime": "4h"
  },
  {
    "priority": "immediate",
    "module": "technical-skills",
    "actions": [
      {
        "type": "move_code",
        "description": "Resolver acoplamento: Routes contém lógica de negócio ou acesso a dados",
        "target": "server/modules/technical-skills/routes.ts",
        "steps": [
          "Identificar código acoplado",
          "Determinar camada correta para o código",
          "Mover código para camada apropriada",
          "Criar interfaces para comunicação entre camadas",
          "Atualizar dependências"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada domain",
        "target": "server/modules/technical-skills/domain/ports/IUserSkillRepository_FIXED.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada application",
        "target": "server/modules/technical-skills/application/controllers/SkillController.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada application",
        "target": "server/modules/technical-skills/application/controllers/UserSkillController.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "create_file",
        "description": "Criar Repository com interface",
        "target": "server/modules/technical-skills/infrastructure/repositories/SkillEntityRepository.ts",
        "code": "import { SkillEntity } from '../../domain/entities/SkillEntity';\nimport { ISkillEntityRepository } from '../../domain/ports/ISkillEntityRepository';\nimport { drizzle } from 'drizzle-orm/neon-http';\nimport * as schema from '@shared/schema';\n\nexport class DrizzleSkillEntityRepository implements ISkillEntityRepository {\n  constructor(private readonly db: ReturnType<typeof drizzle>) {}\n\n  async findById(id: string, tenantId: string): Promise<SkillEntity | null> {\n    // Implementar busca por ID\n    throw new Error('Method not implemented.');\n  }\n\n  async findAll(tenantId: string): Promise<SkillEntity[]> {\n    // Implementar busca de todos\n    throw new Error('Method not implemented.');\n  }\n\n  async create(entity: SkillEntity): Promise<SkillEntity> {\n    // Implementar criação\n    throw new Error('Method not implemented.');\n  }\n\n  async update(id: string, entity: Partial<SkillEntity>, tenantId: string): Promise<SkillEntity | null> {\n    // Implementar atualização\n    throw new Error('Method not implemented.');\n  }\n\n  async delete(id: string, tenantId: string): Promise<boolean> {\n    // Implementar exclusão\n    throw new Error('Method not implemented.');\n  }\n}\n",
        "steps": [
          "Criar interface do Repository na camada Domain",
          "Implementar Repository na camada Infrastructure",
          "Adicionar injeção de dependência",
          "Integrar com Use Cases"
        ]
      }
    ],
    "estimatedTime": "5h"
  },
  {
    "priority": "immediate",
    "module": "schedule-management",
    "actions": [
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada domain",
        "target": "server/modules/schedule-management/domain/entities/Schedule.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada domain",
        "target": "server/modules/schedule-management/domain/ports/IScheduleRepository.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "move_code",
        "description": "Resolver acoplamento: Repository contém possível lógica de negócio",
        "target": "server/modules/schedule-management/infrastructure/repositories/DrizzleScheduleRepository.ts",
        "steps": [
          "Identificar código acoplado",
          "Determinar camada correta para o código",
          "Mover código para camada apropriada",
          "Criar interfaces para comunicação entre camadas",
          "Atualizar dependências"
        ]
      },
      {
        "type": "rename_file",
        "description": "Padronizar nomenclatura: Nome da classe CustomerModule não corresponde ao arquivo Schedule",
        "target": "server/modules/schedule-management/domain/entities/Schedule.ts",
        "steps": [
          "Renomear arquivo seguindo padrão",
          "Atualizar imports em outros arquivos",
          "Atualizar nome da classe/interface",
          "Verificar consistência com padrões do projeto"
        ]
      },
      {
        "type": "create_file",
        "description": "Criar Repository com interface",
        "target": "server/modules/schedule-management/infrastructure/repositories/ScheduleEntityRepository.ts",
        "code": "import { ScheduleEntity } from '../../domain/entities/ScheduleEntity';\nimport { IScheduleEntityRepository } from '../../domain/ports/IScheduleEntityRepository';\nimport { drizzle } from 'drizzle-orm/neon-http';\nimport * as schema from '@shared/schema';\n\nexport class DrizzleScheduleEntityRepository implements IScheduleEntityRepository {\n  constructor(private readonly db: ReturnType<typeof drizzle>) {}\n\n  async findById(id: string, tenantId: string): Promise<ScheduleEntity | null> {\n    // Implementar busca por ID\n    throw new Error('Method not implemented.');\n  }\n\n  async findAll(tenantId: string): Promise<ScheduleEntity[]> {\n    // Implementar busca de todos\n    throw new Error('Method not implemented.');\n  }\n\n  async create(entity: ScheduleEntity): Promise<ScheduleEntity> {\n    // Implementar criação\n    throw new Error('Method not implemented.');\n  }\n\n  async update(id: string, entity: Partial<ScheduleEntity>, tenantId: string): Promise<ScheduleEntity | null> {\n    // Implementar atualização\n    throw new Error('Method not implemented.');\n  }\n\n  async delete(id: string, tenantId: string): Promise<boolean> {\n    // Implementar exclusão\n    throw new Error('Method not implemented.');\n  }\n}\n",
        "steps": [
          "Criar interface do Repository na camada Domain",
          "Implementar Repository na camada Infrastructure",
          "Adicionar injeção de dependência",
          "Integrar com Use Cases"
        ]
      }
    ],
    "estimatedTime": "4h"
  },
  {
    "priority": "immediate",
    "module": "shared",
    "actions": [
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada domain",
        "target": "server/modules/shared/domain/ports/IBaseEntityRepository.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada domain",
        "target": "server/modules/shared/domain/ports/Iindex.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "rename_file",
        "description": "Padronizar nomenclatura: Repository index deve terminar com 'Repository'",
        "target": "server/modules/shared/infrastructure/repositories/index.ts",
        "steps": [
          "Renomear arquivo seguindo padrão",
          "Atualizar imports em outros arquivos",
          "Atualizar nome da classe/interface",
          "Verificar consistência com padrões do projeto"
        ]
      },
      {
        "type": "create_directory",
        "description": "Criar interface I[Entity]Repository no domain e implementar",
        "target": "server/modules/shared/infrastructure/repositories/index.ts",
        "steps": [
          "Criar interface I[Entity]Repository no domain e implementar"
        ]
      },
      {
        "type": "create_directory",
        "description": "Criar interface I[Entity]Repository no domain e implementar",
        "target": "server/modules/shared/infrastructure/repositories/indexRepository.ts",
        "steps": [
          "Criar interface I[Entity]Repository no domain e implementar"
        ]
      },
      {
        "type": "create_file",
        "description": "Criar Repository com interface",
        "target": "server/modules/shared/domain/ports/IindexRepository.ts",
        "code": "import { Iindex } from '../../domain/entities/Iindex';\nimport { IIindexRepository } from '../../domain/ports/IIindexRepository';\nimport { drizzle } from 'drizzle-orm/neon-http';\nimport * as schema from '@shared/schema';\n\nexport class DrizzleIindexRepository implements IIindexRepository {\n  constructor(private readonly db: ReturnType<typeof drizzle>) {}\n\n  async findById(id: string, tenantId: string): Promise<Iindex | null> {\n    // Implementar busca por ID\n    throw new Error('Method not implemented.');\n  }\n\n  async findAll(tenantId: string): Promise<Iindex[]> {\n    // Implementar busca de todos\n    throw new Error('Method not implemented.');\n  }\n\n  async create(entity: Iindex): Promise<Iindex> {\n    // Implementar criação\n    throw new Error('Method not implemented.');\n  }\n\n  async update(id: string, entity: Partial<Iindex>, tenantId: string): Promise<Iindex | null> {\n    // Implementar atualização\n    throw new Error('Method not implemented.');\n  }\n\n  async delete(id: string, tenantId: string): Promise<boolean> {\n    // Implementar exclusão\n    throw new Error('Method not implemented.');\n  }\n}\n",
        "steps": [
          "Criar interface do Repository na camada Domain",
          "Implementar Repository na camada Infrastructure",
          "Adicionar injeção de dependência",
          "Integrar com Use Cases"
        ]
      }
    ],
    "estimatedTime": "4h"
  },
  {
    "priority": "immediate",
    "module": "timecard",
    "actions": [
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada domain",
        "target": "server/modules/timecard/domain/ports/ITimecardRepository.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada application",
        "target": "server/modules/timecard/application/controllers/TimecardApprovalController.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada application",
        "target": "server/modules/timecard/application/controllers/TimecardController.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      },
      {
        "type": "move_code",
        "description": "Resolver acoplamento: Repository contém possível lógica de negócio",
        "target": "server/modules/timecard/infrastructure/repositories/DrizzleTimecardRepository.ts",
        "steps": [
          "Identificar código acoplado",
          "Determinar camada correta para o código",
          "Mover código para camada apropriada",
          "Criar interfaces para comunicação entre camadas",
          "Atualizar dependências"
        ]
      },
      {
        "type": "rename_file",
        "description": "Padronizar nomenclatura: Entity index não segue padrão PascalCase",
        "target": "server/modules/timecard/domain/entities/index.ts",
        "steps": [
          "Renomear arquivo seguindo padrão",
          "Atualizar imports em outros arquivos",
          "Atualizar nome da classe/interface",
          "Verificar consistência com padrões do projeto"
        ]
      },
      {
        "type": "create_directory",
        "description": "Criar interface I[Entity]Repository no domain e implementar",
        "target": "server/modules/timecard/infrastructure/repositories/DrizzleTimecardRepository.ts",
        "steps": [
          "Criar interface I[Entity]Repository no domain e implementar"
        ]
      },
      {
        "type": "create_file",
        "description": "Criar Repository com interface",
        "target": "server/modules/timecard/domain/ports/IindexRepository.ts",
        "code": "import { Iindex } from '../../domain/entities/Iindex';\nimport { IIindexRepository } from '../../domain/ports/IIindexRepository';\nimport { drizzle } from 'drizzle-orm/neon-http';\nimport * as schema from '@shared/schema';\n\nexport class DrizzleIindexRepository implements IIindexRepository {\n  constructor(private readonly db: ReturnType<typeof drizzle>) {}\n\n  async findById(id: string, tenantId: string): Promise<Iindex | null> {\n    // Implementar busca por ID\n    throw new Error('Method not implemented.');\n  }\n\n  async findAll(tenantId: string): Promise<Iindex[]> {\n    // Implementar busca de todos\n    throw new Error('Method not implemented.');\n  }\n\n  async create(entity: Iindex): Promise<Iindex> {\n    // Implementar criação\n    throw new Error('Method not implemented.');\n  }\n\n  async update(id: string, entity: Partial<Iindex>, tenantId: string): Promise<Iindex | null> {\n    // Implementar atualização\n    throw new Error('Method not implemented.');\n  }\n\n  async delete(id: string, tenantId: string): Promise<boolean> {\n    // Implementar exclusão\n    throw new Error('Method not implemented.');\n  }\n}\n",
        "steps": [
          "Criar interface do Repository na camada Domain",
          "Implementar Repository na camada Infrastructure",
          "Adicionar injeção de dependência",
          "Integrar com Use Cases"
        ]
      }
    ],
    "estimatedTime": "5h"
  },
  {
    "priority": "high",
    "module": "customers",
    "actions": [
      {
        "type": "move_code",
        "description": "Resolver acoplamento: Routes contém lógica de negócio ou acesso a dados",
        "target": "server/modules/customers/routes.ts",
        "steps": [
          "Identificar código acoplado",
          "Determinar camada correta para o código",
          "Mover código para camada apropriada",
          "Criar interfaces para comunicação entre camadas",
          "Atualizar dependências"
        ]
      },
      {
        "type": "refactor_code",
        "description": "Refatorar dependência inválida na camada application",
        "target": "server/modules/customers/application/controllers/CompanyController.ts",
        "steps": [
          "Identificar a dependência problemática",
          "Criar interface/port na camada Domain",
          "Implementar interface na camada Infrastructure",
          "Usar injeção de dependência",
          "Remover import direto da dependência externa"
        ]
      }
    ],
    "estimatedTime": "2h"
  },
  {
    "priority": "high",
    "module": "tickets",
    "actions": [
      {
        "type": "move_code",
        "description": "Resolver acoplamento: Routes contém lógica de negócio ou acesso a dados",
        "target": "server/modules/tickets/routes.ts",
        "steps": [
          "Identificar código acoplado",
          "Determinar camada correta para o código",
          "Mover código para camada apropriada",
          "Criar interfaces para comunicação entre camadas",
          "Atualizar dependências"
        ]
      },
      {
        "type": "move_code",
        "description": "Resolver acoplamento: Repository contém possível lógica de negócio",
        "target": "server/modules/tickets/infrastructure/repositories/DrizzleTicketRepository.ts",
        "steps": [
          "Identificar código acoplado",
          "Determinar camada correta para o código",
          "Mover código para camada apropriada",
          "Criar interfaces para comunicação entre camadas",
          "Atualizar dependências"
        ]
      }
    ],
    "estimatedTime": "2h"
  },
  {
    "priority": "low",
    "module": "auth",
    "actions": [
      {
        "type": "move_code",
        "description": "Resolver acoplamento: Repository contém possível lógica de negócio",
        "target": "server/modules/auth/infrastructure/repositories/DrizzleUserRepository.ts",
        "steps": [
          "Identificar código acoplado",
          "Determinar camada correta para o código",
          "Mover código para camada apropriada",
          "Criar interfaces para comunicação entre camadas",
          "Atualizar dependências"
        ]
      }
    ],
    "estimatedTime": "45min"
  },
  {
    "priority": "low",
    "module": "dashboard",
    "actions": [
      {
        "type": "move_code",
        "description": "Resolver acoplamento: Repository contém possível lógica de negócio",
        "target": "server/modules/dashboard/infrastructure/repositories/DrizzleDashboardRepository.ts",
        "steps": [
          "Identificar código acoplado",
          "Determinar camada correta para o código",
          "Mover código para camada apropriada",
          "Criar interfaces para comunicação entre camadas",
          "Atualizar dependências"
        ]
      }
    ],
    "estimatedTime": "45min"
  },
  {
    "priority": "low",
    "module": "custom-fields",
    "actions": [
      {
        "type": "rename_file",
        "description": "Padronizar nomenclatura: Use Case index deve terminar com 'UseCase'",
        "target": "server/modules/custom-fields/application/use-cases/index.ts",
        "steps": [
          "Renomear arquivo seguindo padrão",
          "Atualizar imports em outros arquivos",
          "Atualizar nome da classe/interface",
          "Verificar consistência com padrões do projeto"
        ]
      }
    ],
    "estimatedTime": "15min"
  },
  {
    "priority": "low",
    "module": "people",
    "actions": [
      {
        "type": "rename_file",
        "description": "Padronizar nomenclatura: Use Case index deve terminar com 'UseCase'",
        "target": "server/modules/people/application/use-cases/index.ts",
        "steps": [
          "Renomear arquivo seguindo padrão",
          "Atualizar imports em outros arquivos",
          "Atualizar nome da classe/interface",
          "Verificar consistência com padrões do projeto"
        ]
      }
    ],
    "estimatedTime": "15min"
  }
]