# Conductor - Customer Support Platform

## Overview

Conductor is a modern SaaS customer support platform designed to provide omnichannel support management with a focus on enterprise multitenancy. The platform follows a gradient-focused design system and is built with a full-stack TypeScript architecture using React for the frontend and Node.js/Express for the backend.

## User Preferences

Preferred communication style: Simple, everyday language.

## System Architecture

### Frontend Architecture
- **Framework**: React 18 with TypeScript
- **Styling**: Tailwind CSS with custom gradient design system
- **UI Components**: Radix UI primitives with shadcn/ui components
- **State Management**: TanStack React Query for server state
- **Routing**: Wouter for client-side routing
- **Build Tool**: Vite with custom configuration

### Backend Architecture
- **Runtime**: Node.js with Express.js
- **Language**: TypeScript with ES modules
- **Database**: PostgreSQL with Drizzle ORM
- **Authentication**: Replit's OpenID Connect integration
- **Session Management**: Express sessions with PostgreSQL storage
- **API Design**: RESTful endpoints with structured error handling
- **Architecture Pattern**: Clean Architecture with Domain-Driven Design
- **Domain Layer**: Pure business entities and domain logic
- **Application Layer**: Use Cases and application services
- **Infrastructure Layer**: Database repositories and external services
- **Domain Events**: Event-driven architecture for decoupling

### Design System
- **Primary Theme**: Gradient-focused design with purple/blue color scheme
- **Gradients**: 
  - Primary: `linear-gradient(135deg, #667eea 0%, #764ba2 100%)`
  - Secondary: `linear-gradient(135deg, #f093fb 0%, #f5576c 100%)`
  - Success: `linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)`
- **Component Library**: Custom components built on Radix UI with gradient styling

## Key Components

### Authentication System
- **Provider**: Replit OpenID Connect integration
- **Session Storage**: PostgreSQL-backed sessions using connect-pg-simple
- **Security**: JWT tokens with proper cookie management
- **Authorization**: Role-based access control (admin, agent roles)

### Database Schema
- **Multi-tenancy**: True schema separation - each tenant has dedicated PostgreSQL schema
- **Schema Structure**:
  - Public schema: Users, Tenants, Sessions (shared resources)
  - Tenant schemas: `tenant_{uuid}` with isolated Customers, Tickets, Messages, Activity Logs
- **Core Entities**:
  - Users (stored in public schema with tenant association)
  - Tenants (public schema for tenant management)
  - Customers (tenant-specific schema for complete isolation)
  - Tickets (tenant-specific schema with references to public users)
  - Ticket Messages (tenant-specific schema)
  - Activity Logs (tenant-specific schema)

### API Structure
- **Authentication**: `/api/auth/*` - User authentication and profile
- **Dashboard**: `/api/dashboard/*` - Statistics and activity feeds
- **Customers**: `/api/customers/*` - Customer management
- **Tickets**: `/api/tickets/*` - Support ticket operations
- **Error Handling**: Centralized error middleware with structured responses

### UI Components
- **Layout**: AppShell with Sidebar and Header components
- **Dashboard**: Metric cards, activity feeds, and charts
- **Forms**: React Hook Form with Zod validation
- **Data Display**: Tables, cards, and badges with gradient styling

## Recent Changes
- **2025-01-16**: Implemented Clean Architecture with Domain-Driven Design
  - Created Domain Layer with pure business entities (Customer, Ticket)
  - Implemented Use Cases for application logic separation (CreateCustomer, GetCustomers)
  - Added Repository interfaces for dependency inversion (ICustomerRepository, ITicketRepository)
  - Created Domain Events system for decoupled business logic (CustomerCreated, TicketAssigned)
  - Extracted business logic from controllers into dedicated Use Cases
  - Implemented PostgreSQL schema separation for true multitenancy
  - Created SchemaManager class for tenant schema lifecycle management
  - Updated DatabaseStorage to use tenant-specific database connections
  - Migrated existing data to tenant-specific schemas

## Data Flow

### Request Flow
1. Client makes authenticated request
2. Replit auth middleware validates session
3. Route handler extracts user and tenant context
4. SchemaManager provides tenant-specific database connection
5. Database operations execute in isolated tenant schema
6. Response returned with proper error handling

### Schema Isolation
1. Each tenant gets dedicated PostgreSQL schema `tenant_{uuid}`
2. SchemaManager maintains connection pool per tenant
3. Tenant data completely isolated - no cross-tenant data access possible
4. Shared resources (users, sessions) remain in public schema

### Clean Architecture Implementation

#### Domain Layer (server/domain/)
- **Entities**: Pure business objects with invariants (Customer, Ticket)
- **Repository Interfaces**: Abstractions for data access (ICustomerRepository, ITicketRepository)
- **Domain Events**: Business event definitions (CustomerCreated, TicketAssigned)
- **Business Rules**: Entity methods enforce business logic and validation

#### Application Layer (server/application/)
- **Use Cases**: Orchestrate business logic (CreateCustomerUseCase, GetCustomersUseCase)
- **Controllers**: Handle HTTP requests and responses
- **Services**: Cross-cutting concerns (DependencyContainer)
- **DTOs**: Request/Response data transfer objects

#### Infrastructure Layer (server/infrastructure/)
- **Repositories**: Concrete implementations using Drizzle ORM
- **Event Publishers**: Handle domain event distribution
- **Database**: Schema management and connection handling
- **External Services**: Third-party integrations

### State Management
- **Server State**: TanStack React Query for API data
- **Client State**: React hooks for local component state
- **Authentication State**: Global auth hook with user context
- **Domain Events**: Event-driven updates across bounded contexts

### Real-time Updates
- **Architecture**: Polling-based updates via React Query
- **Frequency**: Configurable refresh intervals for different data types
- **Caching**: Query caching with stale-while-revalidate pattern

## External Dependencies

### Core Dependencies
- **Database**: Neon PostgreSQL with connection pooling
- **Authentication**: Replit OpenID Connect
- **UI Framework**: Radix UI primitives
- **Styling**: Tailwind CSS with PostCSS
- **Validation**: Zod for schema validation
- **Date Handling**: date-fns for date formatting

### Development Tools
- **Build**: Vite with TypeScript compilation
- **Code Quality**: ESLint and TypeScript strict mode
- **Development**: Hot reload with Vite middleware
- **Error Tracking**: Runtime error overlay for development

## Deployment Strategy

### Development Environment
- **Platform**: Replit with integrated development tools
- **Hot Reload**: Vite development server with Express integration
- **Database**: Neon PostgreSQL with environment-based configuration
- **Session Storage**: PostgreSQL-backed sessions

### Production Considerations
- **Build Process**: Vite build for frontend, esbuild for backend
- **Environment Variables**: Database URL, session secrets, auth configuration
- **Static Assets**: Served through Vite's static file handling
- **Database Migrations**: Drizzle Kit for schema management

### Security Features
- **HTTPS**: Enforced in production with secure cookies
- **CORS**: Configured for cross-origin requests
- **Rate Limiting**: Implemented at middleware level
- **Input Validation**: Zod schemas for all user inputs
- **SQL Injection Prevention**: Drizzle ORM with parameterized queries

### Monitoring and Logging
- **Request Logging**: Structured logging with response times
- **Error Tracking**: Centralized error handling with stack traces
- **Performance**: Query timing and caching metrics
- **Development**: Runtime error modal for debugging