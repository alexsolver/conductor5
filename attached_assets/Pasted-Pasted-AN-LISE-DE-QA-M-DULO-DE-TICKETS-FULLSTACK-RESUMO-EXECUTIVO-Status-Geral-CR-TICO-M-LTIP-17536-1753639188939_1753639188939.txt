Pasted--AN-LISE-DE-QA-M-DULO-DE-TICKETS-FULLSTACK-RESUMO-EXECUTIVO-Status-Geral-CR-TICO-M-LTIP-1753637342420_1753637342421.txt
🔍 ANÁLISE DE QA - MÓDULO DE TICKETS FULLSTACK
📊 RESUMO EXECUTIVO
Status Geral: ⚠️ CRÍTICO - MÚLTIPLAS INCONSISTÊNCIAS IDENTIFICADAS
Funcionalidade Base: ✅ Operacional (CRUD básico funciona)
Qualidade do Código: ❌ Baixa (múltiplas inconsistências)
Manutenibilidade: ❌ Comprometida

🚨 INCONSISTÊNCIAS CRÍTICAS IDENTIFICADAS
1. INCONSISTÊNCIAS DE MAPEAMENTO FRONTEND-BACKEND
❌ Problema: Campos com Nomenclatura Divergente
// FRONTEND (TicketDetails.tsx) - camelCase
callerId, beneficiaryId, assignedToId, customerCompanyId
// BACKEND (routes.ts) - snake_case  
caller_id, beneficiary_id, assigned_to_id, customer_id
Impacto: Falhas na sincronização de dados entre cliente e servidor.

❌ Problema: Campo Location Inconsistente
// Código tenta usar ambos:
location_id: data.locationId,        // ❌ Campo inexistente no BD
location: data.location,             // ✅ Campo correto
Evidência no Código:

// server/modules/favorecidos/routes.ts linha 143
const mappedData = {
  // CORRIGIDO: Location mapping adequado
  location_id: data.locationId,        // Para referência FK
  location: data.location,             // Para texto livre
}
2. INCONSISTÊNCIAS NO SCHEMA DE VALIDAÇÃO
❌ Problema: Esquemas Zod Desalinhados
// shared/ticket-validation.ts - Schema completo
export const ticketFormSchema = z.object({
  callerId: z.string().uuid().optional(),
  // ... 40+ campos
});
// client/src/pages/TicketDetails.tsx - Schema reduzido  
const ticketFormSchema = z.object({
  subject: z.string().min(1),
  // ... apenas 15 campos
});
Impacto: Validações inconsistentes entre diferentes partes do sistema.

3. INCONSISTÊNCIAS DE COMPONENTES DINÂMICOS
⚠️ Problema: DynamicBadge Props Filtradas Incorretamente
// client/src/components/DynamicBadge.tsx
const { fieldName: _fieldName, value: _value, ...cleanProps } = props;
// ✅ RESOLVIDO mas indica padrão inconsistente no projeto
4. INCONSISTÊNCIAS DE DADOS MOCKADOS vs REAIS
❌ Problema: Mistura de Dados Hardcoded e API
// client/src/pages/TicketDetails.tsx linhas 800-900
// PROBLEMA 4 RESOLVIDO: Mas ainda há vestígios de dados mockados
const sampleHistory = [
  {
    id: "1",
    type: "status_change",
    // ... dados hardcoded
  }
];
// vs dados reais da API
if (ticketHistoryData?.success && ticketHistoryData?.data) {
  setHistory(ticketHistoryData.data);
}
5. INCONSISTÊNCIAS DE AUTENTICAÇÃO E AUTORIZAÇÃO
❌ Problema: Middleware de Autenticação Inconsistente
// server/modules/tickets/routes.ts
// Alguns endpoints usam jwtAuth como middleware
router.get('/', jwtAuth, async (req: AuthenticatedRequest, res) => {
// Outros aplicam jwtAuth inline  
ticketsRouter.get('/:id', jwtAuth, async (req: AuthenticatedRequest, res) => {
6. INCONSISTÊNCIAS DE TRATAMENTO DE ERROS
❌ Problema: Padrões de Erro Divergentes
// Padrão 1 - Detalhado
res.status(500).json({ 
  success: false,
  message: "Failed to fetch favorecidos",
  error: error instanceof Error ? error.message : "Unknown error"
});
// Padrão 2 - Simples
res.status(500).json({ message: "Failed to fetch tickets" });
📋 TABELA DE INCONSISTÊNCIAS POR SEVERIDADE
Categoria	Descrição	Severidade	Status	Arquivos Afetados
Mapeamento Dados	callerId vs caller_id	🔴 Crítica	❌ Não Resolvido	TicketDetails.tsx, routes.ts
Schema Validation	Esquemas Zod divergentes	🔴 Crítica	❌ Não Resolvido	ticket-validation.ts, TicketDetails.tsx
Campo Location	location vs location_id	🔴 Crítica	❌ Não Resolvido	Múltiplos arquivos
Dados Mockados	Mistura real vs hardcoded	🟡 Média	⚠️ Parcial	TicketDetails.tsx
Autenticação	Middleware inconsistente	🟡 Média	❌ Não Resolvido	routes.ts
Tratamento Erro	Padrões divergentes	🟡 Média	❌ Não Resolvido	Múltiplos arquivos
🛠️ RECOMENDAÇÕES DE CORREÇÃO
Prioridade 1 - Críticas (Imediatas)
Padronizar Mapeamento de Campos

Criar função centralizada de conversão camelCase ↔ snake_case
Aplicar em todos os endpoints de tickets
Unificar Esquemas de Validação

Usar um único schema Zod como fonte da verdade
Derivar esquemas específicos a partir do schema principal
Resolver Inconsistência do Campo Location

Definir se será location (texto) ou location_id (FK)
Aplicar consistentemente em todo o sistema
Prioridade 2 - Importantes (Próximas Sprints)
Eliminar Dados Hardcoded

Remover todos os dados mockados restantes
Garantir 100% de dados vindos da API
Padronizar Middleware de Autenticação

Aplicar padrão único em todas as rotas
Documentar padrão no guia de desenvolvimento
Prioridade 3 - Melhorias (Refatoração)
Unificar Tratamento de Erros
Criar interface padrão para respostas de erro
Aplicar em todos os endpoints
📈 MÉTRICAS DE QUALIDADE ATUAL
Métrica	Valor Atual	Meta	Status
Cobertura de Testes	0%	80%	❌
Consistência de Nomenclatura	40%	95%	❌
Padronização de Erros	30%	90%	❌
Eliminação de Hardcode	70%	100%	⚠️
Validação Unificada	20%	95%	❌