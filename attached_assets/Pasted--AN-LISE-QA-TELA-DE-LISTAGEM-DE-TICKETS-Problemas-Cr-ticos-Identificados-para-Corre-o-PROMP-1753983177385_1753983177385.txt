ğŸ” ANÃLISE QA - TELA DE LISTAGEM DE TICKETS
Problemas CrÃ­ticos Identificados para CorreÃ§Ã£o

ğŸ“‹ PROMPT DE CORREÃ‡ÃƒO PARA FERRAMENTA DE VIBE CODING:
ğŸš¨ PROBLEMAS CRÃTICOS DE PERFORMANCE
1. ERRO CRÃTICO DE TIPO DE DADOS - CAMPO FOLLOWERS
ERRO: column "followers" is of type text[] but expression is of type record
LOCALIZAÃ‡ÃƒO: server/storage-simple.ts linha 523
IMPACTO: Falha completa na atualizaÃ§Ã£o de tickets
2. VALIDAÃ‡ÃƒO DE SCHEMA INCONSISTENTE
PROBLEMA: Form validation rejeitando valores vÃ¡lidos do backend
ERRO: Invalid enum value. Expected 'novo' | 'aberto' | 'em_andamento' | 'resolvido' | 'fechado', received 'in_progress'
IMPACTO: UsuÃ¡rios nÃ£o conseguem salvar alteraÃ§Ãµes
3. CARREGAMENTO MÃšLTIPLO DESNECESSÃRIO
PROBLEMA: API /api/ticket-config/field-options sendo chamada mÃºltiplas vezes simultaneamente
IMPACTO: DegradaÃ§Ã£o de performance e uso excessivo de recursos
âš¡ CORREÃ‡Ã•ES OBRIGATÃ“RIAS DE PERFORMANCE
CORREÃ‡ÃƒO 1: Fixar Tipo de Dados do Campo Followers
// server/storage-simple.ts
// ANTES:
followers: ticketData.followers
// DEPOIS:
followers: Array.isArray(ticketData.followers) 
  ? ticketData.followers 
  : typeof ticketData.followers === 'string' 
    ? [ticketData.followers] 
    : []
CORREÃ‡ÃƒO 2: Unificar Valores de Enum Status
// shared/ticket-validation.ts
const statusSchema = z.enum([
  'new', 'open', 'in_progress', 'resolved', 'closed', 'cancelled'
]);
// Mapear valores do backend para frontend:
const mapBackendToFrontend = (status: string) => {
  const mapping = {
    'novo': 'new',
    'aberto': 'open', 
    'em_andamento': 'in_progress',
    'resolvido': 'resolved',
    'fechado': 'closed'
  };
  return mapping[status] || status;
};
CORREÃ‡ÃƒO 3: Implementar Cache para Field Options
// hooks/useFieldColors.ts
const { data: fieldOptions } = useQuery({
  queryKey: ["/api/ticket-config/field-options"],
  staleTime: 5 * 60 * 1000, // 5 minutos
  cacheTime: 10 * 60 * 1000, // 10 minutos
  refetchOnWindowFocus: false
});
ğŸ¨ MELHORIAS DE UX OBRIGATÃ“RIAS
PROBLEMA 4: Loading States Inadequados
CORREÃ‡ÃƒO: Implementar skeleton loading para tabela de tickets
SUBSTITUIR: Spinner genÃ©rico
POR: Loading states especÃ­ficos para cada seÃ§Ã£o
PROBLEMA 5: Feedback Visual Insuficiente
CORREÃ‡ÃƒO: Estados visuais para:
- Tickets com relacionamentos (Ã­cone de link)
- ExpansÃ£o/colapso de relacionamentos
- Estados de erro em tempo real
- Progresso de salvamento
PROBLEMA 6: Responsividade da Tabela
CORREÃ‡ÃƒO: Implementar scroll horizontal responsivo
ADICIONAR: Colunas colapsÃ¡veis em mobile
IMPLEMENTAR: Redimensionamento de colunas funcional
ğŸš€ OTIMIZAÃ‡Ã•ES DE PERFORMANCE ESPECÃFICAS
OTIMIZAÃ‡ÃƒO 1: React.memo para Componentes de CÃ©lula
const TableCellComponent = memo(({ column, ticket }: CellProps) => {
  // RenderizaÃ§Ã£o otimizada
}, (prevProps, nextProps) => {
  return prevProps.ticket.id === nextProps.ticket.id &&
         prevProps.ticket.updated_at === nextProps.ticket.updated_at;
});
OTIMIZAÃ‡ÃƒO 2: VirtualizaÃ§Ã£o para Listas Grandes
// Implementar react-window para tabelas com >100 tickets
import { FixedSizeList as List } from 'react-window';
OTIMIZAÃ‡ÃƒO 3: Debounce para Filtros
const [searchTerm, setSearchTerm] = useState("");
const debouncedSearch = useDebounce(searchTerm, 300);
ğŸ”§ CORREÃ‡Ã•ES TÃ‰CNICAS CRÃTICAS
BUG 1: Relacionamentos de Tickets
PROBLEMA: Sistema mostra tickets com relacionamentos inconsistentemente
CORREÃ‡ÃƒO: Padronizar verificaÃ§Ã£o de relacionamentos na inicializaÃ§Ã£o
BUG 2: Mapeamento de Campos
PROBLEMA: InconsistÃªncia entre nomes de campos frontend/backend
CORREÃ‡ÃƒO: Implementar camada de transformaÃ§Ã£o consistente
BUG 3: Redimensionamento de Colunas
PROBLEMA: Colunas nÃ£o mantÃªm largura apÃ³s redimensionamento
CORREÃ‡ÃƒO: Persistir configuraÃ§Ãµes de coluna no localStorage
ğŸ“Š MÃ‰TRICAS DE PERFORMANCE ALVO
TEMPO DE CARREGAMENTO INICIAL: < 2 segundos
TEMPO DE RESPOSTA FILTROS: < 300ms
TEMPO DE SALVAMENTO: < 1 segundo
TAXA DE ERRO: < 1%
SCORE LIGHTHOUSE PERFORMANCE: > 90