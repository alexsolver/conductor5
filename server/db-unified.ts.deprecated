// ‚ùå DEPRECATED FILE - DO NOT USE
// This file has been deprecated in favor of unified schema architecture
// Use: import from '@shared/schema' instead
// 
// Reason: Causes architecture fragmentation and conflicts
// Migration: Use server/db.ts and shared/schema-master.ts

// Unified Database Manager - Complete Recreation of Tables
import { neon } from "@neondatabase/serverless";
import { drizzle } from "drizzle-orm/neon-http";
import { sql } from "drizzle-orm";

const connectionString = process.env.DATABASE_URL;
if (!connectionString) {
  throw new Error("DATABASE_URL environment variable is required");
}

const sqlConnection = neon(connectionString);
const db = drizzle(sqlConnection);

export class UnifiedDatabaseManager {
  
  async recreateAllTables(): Promise<void> {
    console.log('üîÑ Starting complete table recreation...');
    
    try {
      // 1. Drop all existing tenant schemas first
      await this.dropAllTenantSchemas();
      
      // 2. Recreate public schema tables
      await this.createPublicTables();
      
      // 3. Recreate all tenant schemas with new structure
      await this.recreateAllTenantSchemas();
      
      console.log('‚úÖ Complete table recreation completed successfully!');
    } catch (error) {
      console.error('‚ùå Error during table recreation:', error);
      throw error;
    }
  }

  private async dropAllTenantSchemas(): Promise<void> {
    console.log('üóëÔ∏è Dropping all existing tenant schemas...');
    
    try {
      // Get all tenant schemas
      const schemas = await db.execute(sql`
        SELECT schema_name 
        FROM information_schema.schemata 
        WHERE schema_name LIKE 'tenant_%'
      `);

      // Drop each tenant schema
      for (const schema of schemas.rows) {
        const schemaName = schema.schema_name;
        console.log(`Dropping schema: ${schemaName}`);
        await db.execute(sql.raw(`DROP SCHEMA IF EXISTS "${schemaName}" CASCADE`));
      }
      
      console.log('‚úÖ All tenant schemas dropped');
    } catch (error) {
      console.error('Error dropping tenant schemas:', error);
      throw error;
    }
  }

  private async createPublicTables(): Promise<void> {
    console.log('üìã Creating public schema tables...');
    
    try {
      // Drop existing public tables if they exist
      await db.execute(sql`DROP TABLE IF EXISTS sessions CASCADE`);
      await db.execute(sql`DROP TABLE IF EXISTS users CASCADE`);
      await db.execute(sql`DROP TABLE IF EXISTS tenants CASCADE`);

      // Create tenants table
      await db.execute(sql`
        CREATE TABLE tenants (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          name VARCHAR(100) NOT NULL,
          subdomain VARCHAR(50) UNIQUE NOT NULL,
          status VARCHAR(20) DEFAULT 'active' NOT NULL,
          settings JSONB DEFAULT '{}',
          created_at TIMESTAMP DEFAULT NOW() NOT NULL,
          updated_at TIMESTAMP DEFAULT NOW() NOT NULL
        )
      `);

      // Create users table
      await db.execute(sql`
        CREATE TABLE users (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          email VARCHAR(255) UNIQUE NOT NULL,
          first_name VARCHAR(100),
          last_name VARCHAR(100),
          role VARCHAR(50) DEFAULT 'agent' NOT NULL,
          tenant_id UUID REFERENCES tenants(id) NOT NULL,
          password_hash TEXT NOT NULL,
          profile_image_url TEXT,
          is_active BOOLEAN DEFAULT true NOT NULL,
          last_login_at TIMESTAMP,
          created_at TIMESTAMP DEFAULT NOW() NOT NULL,
          updated_at TIMESTAMP DEFAULT NOW() NOT NULL
        )
      `);

      // Create sessions table
      await db.execute(sql`
        CREATE TABLE sessions (
          sid VARCHAR(128) PRIMARY KEY,
          sess JSONB NOT NULL,
          expire TIMESTAMP NOT NULL
        )
      `);

      // Create indexes
      await db.execute(sql`CREATE INDEX idx_users_tenant_id ON users(tenant_id)`);
      await db.execute(sql`CREATE INDEX idx_users_email ON users(email)`);
      await db.execute(sql`CREATE INDEX idx_tenants_subdomain ON tenants(subdomain)`);

      console.log('‚úÖ Public tables created successfully');
    } catch (error) {
      console.error('Error creating public tables:', error);
      throw error;
    }
  }

  private async recreateAllTenantSchemas(): Promise<void> {
    console.log('üè¢ Recreating all tenant schemas...');
    
    // Get existing tenant IDs from any remaining data or create sample tenants
    const sampleTenants = [
      '3f99462f-3621-4b1b-bea8-782acc50d62e',
      '715c510a-3db5-4510-880a-9a1a5c320100',
      '78a4c88e-0e85-4f7c-ad92-f472dad50d7a',
      'cb9056df-d964-43d7-8fd8-b0cc00a72056'
    ];

    // First, ensure tenants exist in public table
    for (const tenantId of sampleTenants) {
      await db.execute(sql`
        INSERT INTO tenants (id, name, subdomain, status)
        VALUES (${tenantId}, 'Tenant ' || substring(${tenantId}, 1, 8), 'tenant-' || substring(${tenantId}, 1, 8), 'active')
        ON CONFLICT (id) DO NOTHING
      `);
    }

    // Create tenant schemas with new structure
    for (const tenantId of sampleTenants) {
      await this.createTenantSchema(tenantId);
    }
    
    console.log('‚úÖ All tenant schemas recreated successfully');
  }

  async createTenantSchema(tenantId: string): Promise<void> {
    console.log(`üèóÔ∏è Creating tenant schema for: ${tenantId}`);
    
    try {
      const schemaName = `tenant_${tenantId.replace(/-/g, '_')}`;
      
      // Create schema
      await db.execute(sql.raw(`CREATE SCHEMA IF NOT EXISTS "${schemaName}"`));
      
      // Create SOLICITANTES table (replaces customers)
      await db.execute(sql.raw(`
        CREATE TABLE "${schemaName}".solicitantes (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          tenant_id VARCHAR(36) NOT NULL DEFAULT '${tenantId}',
          first_name VARCHAR(100),
          last_name VARCHAR(100),
          email VARCHAR(255),
          phone VARCHAR(20),
          documento VARCHAR(50),
          tipo_pessoa VARCHAR(20) DEFAULT 'fisica',
          preferencia_contato VARCHAR(20) DEFAULT 'email',
          idioma VARCHAR(10) DEFAULT 'pt-BR',
          timezone VARCHAR(50) DEFAULT 'America/Sao_Paulo',
          observacoes TEXT,
          verified BOOLEAN DEFAULT false,
          active BOOLEAN DEFAULT true,
          suspended BOOLEAN DEFAULT false,
          external_id VARCHAR(100),
          role VARCHAR(100),
          notes TEXT,
          avatar TEXT,
          signature TEXT,
          locale VARCHAR(10) DEFAULT 'pt-BR',
          language VARCHAR(10) DEFAULT 'pt-BR',
          created_at TIMESTAMP DEFAULT NOW() NOT NULL,
          updated_at TIMESTAMP DEFAULT NOW() NOT NULL,
          
          CONSTRAINT customers_tenant_id_uuid_format CHECK (LENGTH(tenant_id::text) = 36 AND tenant_id::text ~ '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$'),
          CONSTRAINT customers_tenant_email_unique UNIQUE (tenant_id, email)
        )
      `));

      // Create FAVORECIDOS table (external contacts)
      await db.execute(sql.raw(`
        CREATE TABLE "${schemaName}".favorecidos (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          tenant_id VARCHAR(36) NOT NULL DEFAULT '${tenantId}',
          nome VARCHAR(200) NOT NULL,
          email VARCHAR(255),
          telefone VARCHAR(20),
          documento VARCHAR(50),
          endereco TEXT,
          pode_interagir BOOLEAN DEFAULT false,
          tipo_vinculo VARCHAR(50) DEFAULT 'outro',
          observacoes TEXT,
          ativo BOOLEAN DEFAULT true,
          created_at TIMESTAMP DEFAULT NOW() NOT NULL,
          updated_at TIMESTAMP DEFAULT NOW() NOT NULL,
          
          CONSTRAINT favorecidos_tenant_id_uuid_format CHECK (LENGTH(tenant_id::text) = 36 AND tenant_id::text ~ '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$'),
          CONSTRAINT favorecidos_tenant_email_unique UNIQUE (tenant_id, email)
        )
      `));

      // Create TICKETS table (updated to reference solicitantes)
      await db.execute(sql.raw(`
        CREATE TABLE "${schemaName}".tickets (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          tenant_id VARCHAR(36) NOT NULL DEFAULT '${tenantId}',
          number VARCHAR(50),
          subject VARCHAR(255) NOT NULL,
          short_description TEXT,
          description TEXT,
          status VARCHAR(50) DEFAULT 'open' NOT NULL,
          priority VARCHAR(20) DEFAULT 'medium',
          category VARCHAR(100),
          subcategory VARCHAR(100),
          impact VARCHAR(20) DEFAULT 'low',
          urgency VARCHAR(20) DEFAULT 'low',
          state VARCHAR(50) DEFAULT 'new',
          
          solicitante_id UUID REFERENCES "${schemaName}".solicitantes(id),
          caller_id UUID,
          opened_by_id UUID,
          assigned_to_id UUID,
          assignment_group VARCHAR(100),
          
          business_impact TEXT,
          symptoms TEXT,
          root_cause TEXT,
          workaround TEXT,
          contact_type VARCHAR(50),
          notify BOOLEAN DEFAULT true,
          
          opened_at TIMESTAMP DEFAULT NOW(),
          resolved_at TIMESTAMP,
          closed_at TIMESTAMP,
          resolution_code VARCHAR(100),
          resolution_notes TEXT,
          close_notes TEXT,
          work_notes TEXT,
          
          created_at TIMESTAMP DEFAULT NOW() NOT NULL,
          updated_at TIMESTAMP DEFAULT NOW() NOT NULL,
          
          CONSTRAINT tickets_tenant_id_uuid_format CHECK (LENGTH(tenant_id::text) = 36 AND tenant_id::text ~ '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$'),
          CONSTRAINT tickets_tenant_number_unique UNIQUE (tenant_id, number)
        )
      `));

      // Create TICKET_MESSAGES table
      await db.execute(sql.raw(`
        CREATE TABLE "${schemaName}".ticket_messages (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          tenant_id VARCHAR(36) NOT NULL DEFAULT '${tenantId}',
          ticket_id UUID REFERENCES "${schemaName}".tickets(id) NOT NULL,
          user_id UUID,
          content TEXT NOT NULL,
          is_internal BOOLEAN DEFAULT false,
          created_at TIMESTAMP DEFAULT NOW() NOT NULL,
          updated_at TIMESTAMP DEFAULT NOW() NOT NULL,
          
          CONSTRAINT ticket_messages_tenant_id_uuid_format CHECK (LENGTH(tenant_id::text) = 36 AND tenant_id::text ~ '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$')
        )
      `));

      // Create LOCATIONS table
      await db.execute(sql.raw(`
        CREATE TABLE "${schemaName}".locations (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          tenant_id VARCHAR(36) NOT NULL DEFAULT '${tenantId}',
          name VARCHAR(200) NOT NULL,
          address TEXT,
          city VARCHAR(100),
          state VARCHAR(50),
          country VARCHAR(50) DEFAULT 'Brasil',
          postal_code VARCHAR(20),
          latitude VARCHAR(50),
          longitude VARCHAR(50),
          active BOOLEAN DEFAULT true,
          created_at TIMESTAMP DEFAULT NOW() NOT NULL,
          updated_at TIMESTAMP DEFAULT NOW() NOT NULL,
          
          CONSTRAINT locations_tenant_id_uuid_format CHECK (LENGTH(tenant_id::text) = 36 AND tenant_id::text ~ '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$'),
          CONSTRAINT locations_tenant_name_unique UNIQUE (tenant_id, name)
        )
      `));

      // Create ACTIVITY_LOGS table
      await db.execute(sql.raw(`
        CREATE TABLE "${schemaName}".activity_logs (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          tenant_id VARCHAR(36) NOT NULL DEFAULT '${tenantId}',
          entity_type VARCHAR(50) NOT NULL,
          entity_id UUID NOT NULL,
          action VARCHAR(100) NOT NULL,
          user_id UUID,
          details JSONB,
          created_at TIMESTAMP DEFAULT NOW() NOT NULL,
          
          CONSTRAINT activity_logs_tenant_id_uuid_format CHECK (LENGTH(tenant_id::text) = 36 AND tenant_id::text ~ '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$')
        )
      `));

      // Create indexes for performance
      await db.execute(sql.raw(`CREATE INDEX idx_${schemaName}_solicitantes_tenant_id ON "${schemaName}".solicitantes(tenant_id)`));
      await db.execute(sql.raw(`CREATE INDEX idx_${schemaName}_solicitantes_email ON "${schemaName}".solicitantes(email)`));
      await db.execute(sql.raw(`CREATE INDEX idx_${schemaName}_favorecidos_tenant_id ON "${schemaName}".favorecidos(tenant_id)`));
      await db.execute(sql.raw(`CREATE INDEX idx_${schemaName}_tickets_tenant_id ON "${schemaName}".tickets(tenant_id)`));
      await db.execute(sql.raw(`CREATE INDEX idx_${schemaName}_tickets_status ON "${schemaName}".tickets(status)`));
      await db.execute(sql.raw(`CREATE INDEX idx_${schemaName}_tickets_solicitante_id ON "${schemaName}".tickets(solicitante_id)`));

      // Insert sample data
      await this.insertSampleData(schemaName, tenantId);
      
      console.log(`‚úÖ Tenant schema created successfully: ${schemaName}`);
    } catch (error) {
      console.error(`Error creating tenant schema for ${tenantId}:`, error);
      throw error;
    }
  }

  private async insertSampleData(schemaName: string, tenantId: string): Promise<void> {
    try {
      // Insert sample locations
      await db.execute(sql.raw(`
        INSERT INTO "${schemaName}".locations (tenant_id, name, address, city, state, country)
        VALUES 
          ('${tenantId}', 'Sede Principal', 'Av. Paulista, 1000', 'S√£o Paulo', 'SP', 'Brasil'),
          ('${tenantId}', 'Filial Rio', 'Rua Copacabana, 500', 'Rio de Janeiro', 'RJ', 'Brasil'),
          ('${tenantId}', 'Centro de Distribui√ß√£o', 'Rod. Anhanguera, km 25', 'Osasco', 'SP', 'Brasil')
      `));

      // Insert sample solicitantes
      await db.execute(sql.raw(`
        INSERT INTO "${schemaName}".solicitantes (tenant_id, first_name, last_name, email, phone, documento, tipo_pessoa)
        VALUES 
          ('${tenantId}', 'Jo√£o', 'Silva', 'joao.silva@exemplo.com', '(11) 99999-1111', '123.456.789-01', 'fisica'),
          ('${tenantId}', 'Maria', 'Santos', 'maria.santos@exemplo.com', '(11) 99999-2222', '987.654.321-02', 'fisica')
      `));

      // Insert sample favorecidos
      await db.execute(sql.raw(`
        INSERT INTO "${schemaName}".favorecidos (tenant_id, nome, email, telefone, tipo_vinculo, pode_interagir)
        VALUES 
          ('${tenantId}', 'Empresa ABC Ltda', 'contato@abc.com', '(11) 3333-4444', 'fornecedor', true),
          ('${tenantId}', 'Parceiro XYZ', 'parceria@xyz.com', '(11) 5555-6666', 'parceiro', false)
      `));

      // Insert sample tickets
      await db.execute(sql.raw(`
        INSERT INTO "${schemaName}".tickets (tenant_id, number, subject, description, status, priority)
        VALUES 
          ('${tenantId}', 'TK-000001', 'Problema com sistema', 'Sistema apresentando lentid√£o', 'open', 'high'),
          ('${tenantId}', 'TK-000002', 'Solicita√ß√£o de acesso', 'Novo usu√°rio precisa de acesso', 'open', 'medium')
      `));

      console.log(`‚úÖ Sample data inserted for ${schemaName}`);
    } catch (error) {
      console.error(`Error inserting sample data for ${schemaName}:`, error);
      // Don't throw - sample data is not critical
    }
  }

  async validateTenantSchema(tenantId: string): Promise<boolean> {
    try {
      const schemaName = `tenant_${tenantId.replace(/-/g, '_')}`;
      
      // Check if all required tables exist
      const result = await db.execute(sql`
        SELECT table_name 
        FROM information_schema.tables 
        WHERE table_schema = ${schemaName}
        AND table_name IN ('solicitantes', 'favorecidos', 'tickets', 'ticket_messages', 'locations', 'activity_logs')
      `);

      return result.rows.length >= 6;
    } catch (error) {
      console.error(`Error validating tenant schema for ${tenantId}:`, error);
      return false;
    }
  }
}

export const unifiedDatabaseManager = new UnifiedDatabaseManager();