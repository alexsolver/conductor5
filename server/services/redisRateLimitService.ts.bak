// REMOVED: Redis dependency
import { Request, Response, NextFunction } from 'express';

export interface RateLimitConfig {
  windowMs: number;
  maxRequests: number;
  keyGenerator?: (req: Request) => string;
  skipSuccessfulRequests?: boolean;
  skipFailedRequests?: boolean;
  onLimitReached?: (req: Request, res: Response) => void;
}

export interface RateLimitInfo {
  totalHits: number;
  remainingRequests: number;
  resetTime: Date;
  isLimited: boolean;
}

export class RedisRateLimitService {
  private static instance: RedisRateLimitService;

  private memoryStore = new Map<string, { count: number; resetTime: number }>();

  constructor() {
    // REMOVED: Redis dependency - using memory-only approach
    // Clean up expired entries every 5 minutes
    setInterval(() => {
      const now = Date.now();
      for (const [key, value] of this.memoryStore.entries()) {
        if (value.resetTime <= now) {
          this.memoryStore.delete(key);
        }
      }
    }, 5 * 60 * 1000);
  }

  static getInstance(): RedisRateLimitService {
    if (!RedisRateLimitService.instance) {
      RedisRateLimitService.instance = new RedisRateLimitService();
    }
    return RedisRateLimitService.instance;
  }

  private getKey(identifier: string, window: number): string {
    return `rate_limit:${identifier}:${window}`;
  }

  async checkRateLimit(identifier: string, config: RateLimitConfig): Promise<RateLimitInfo> {
    const windowStart = Math.floor(Date.now() / config.windowMs) * config.windowMs;
    const key = this.getKey(identifier, windowStart);
    const now = Date.now();
    
    // Memory-based rate limiting
    const existing = this.memoryStore.get(key);
    let currentCount = 1;
    const resetTime = new Date(windowStart + config.windowMs);

    if (existing && existing.resetTime > now) {
      currentCount = existing.count + 1;
    }

    this.memoryStore.set(key, {
      count: currentCount,
      resetTime: resetTime.getTime()
    });

    return {
      totalHits: currentCount,
      remainingRequests: Math.max(0, config.maxRequests - currentCount),
      resetTime,
      isLimited: currentCount > config.maxRequests
    };
  }

  async resetRateLimit(identifier: string, windowMs: number): Promise<void> {
    const windowStart = Math.floor(Date.now() / windowMs) * windowMs;
    const key = this.getKey(identifier, windowStart);
    this.memoryStore.delete(key);
  }
}

// Rate limit configurations
export const RATE_LIMIT_CONFIGS = {
  LOGIN: {
    windowMs: 15 * 60 * 1000, // 15 minutes
    maxRequests: 5, // 5 attempts per window
    keyGenerator: (req: Request) => `login:${req.ip}:${req.body?.email || 'unknown'}`
  },
  REGISTRATION: {
    windowMs: 60 * 60 * 1000, // 1 hour
    maxRequests: 3, // 3 registrations per hour per IP
    keyGenerator: (req: Request) => `register:${req.ip}`
  },
  PASSWORD_RESET: {
    windowMs: 60 * 60 * 1000, // 1 hour
    maxRequests: 3, // 3 password reset attempts per hour
    keyGenerator: (req: Request) => `password_reset:${req.body?.email || req.ip}`
  },
  API_GENERAL: {
    windowMs: 15 * 60 * 1000, // 15 minutes
    maxRequests: 100, // 100 requests per 15 minutes
    keyGenerator: (req: Request) => `api:${req.ip}`
  }
};

// Middleware creator function
export function createMemoryRateLimitMiddleware(config: RateLimitConfig) {
  const rateLimiter = RedisRateLimitService.getInstance();

  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const key = config.keyGenerator ? config.keyGenerator(req) : req.ip;
      const limitInfo = await rateLimiter.checkRateLimit(key, config);

      // Set rate limit headers
      res.set({
        'X-RateLimit-Limit': config.maxRequests.toString(),
        'X-RateLimit-Remaining': limitInfo.remainingRequests.toString(),
        'X-RateLimit-Reset': Math.ceil(limitInfo.resetTime.getTime() / 1000).toString()
      });

      if (limitInfo.isLimited) {
        if (config.onLimitReached) {
          config.onLimitReached(req, res);
        }

        return res.status(429).json({
          message: 'Too many requests',
          resetTime: limitInfo.resetTime,
          remainingRequests: limitInfo.remainingRequests
        });
      }

      next();
    } catch (error) {
      console.error('Rate limiting error:', error);
      // On rate limiter error, allow the request to proceed
      next();
    }
  };
}