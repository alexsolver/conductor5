import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage-simple";
import { schemaManager } from "./db";
import { jwtAuth, AuthenticatedRequest } from "./middleware/jwtAuth";
import { requirePermission, requireTenantAccess } from "./middleware/rbacMiddleware";
import { createCSPMiddleware, cspReportRouter } from "./middleware/cspMiddleware";
import { createMemoryRateLimitMiddleware, RATE_LIMIT_CONFIGS } from "./services/redisRateLimitService";
import { createFeatureFlagMiddleware } from "./services/featureFlagService";
import cookieParser from "cookie-parser";
import { insertCustomerSchema, insertTicketSchema, insertTicketMessageSchema } from "@shared/schema";
import { eq, and } from "drizzle-orm";
import { z } from "zod";
import ticketConfigRoutes from "./routes/ticketConfigRoutes";
import userManagementRoutes from "./routes/userManagementRoutes";
import tenantAdminTeamRoutes from "./routes/tenantAdminTeamRoutes";
import { integrityRouter as integrityRoutes } from './routes/integrityRoutes';
import systemScanRoutes from './routes/systemScanRoutes';
import { technicalSkillsRoutes } from './modules/technical-skills/routes';
import internalFormsRoutes from './modules/internal-forms/routes';
// Removed: external-contacts routes - functionality eliminated
import locationRoutes from './routes/locationRoutes';
import ticketRelationshipsRoutes from './routes/ticketRelationships';
import { omniBridgeRoutes } from './modules/omni-bridge/routes';
import saasAdminRoutes from './modules/saas-admin/routes';
import tenantAdminRoutes from './modules/tenant-admin/routes';
import { dashboardRoutes } from './modules/dashboard/routes';
// Removed: journeyRoutes - functionality eliminated from system
import timecardRoutes from './routes/timecardRoutes';
import scheduleRoutes from './modules/schedule-management/routes';
import schemaConsolidationRoutes from './routes/schemaConsolidationRoutes';

export async function registerRoutes(app: Express): Promise<Server> {
  // Add cookie parser middleware
  app.use(cookieParser());

  // Apply CSP middleware
  app.use(createCSPMiddleware({
    'script-src': ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
    'style-src': ["'self'", "'unsafe-inline'"]
  }));

  // Apply memory-based rate limiting middleware  
  app.use('/api/auth/login', createMemoryRateLimitMiddleware(RATE_LIMIT_CONFIGS.LOGIN));
  app.use('/api/auth/register', createMemoryRateLimitMiddleware(RATE_LIMIT_CONFIGS.REGISTRATION));
  app.use('/api/auth/password-reset', createMemoryRateLimitMiddleware(RATE_LIMIT_CONFIGS.PASSWORD_RESET));
  app.use('/api', createMemoryRateLimitMiddleware(RATE_LIMIT_CONFIGS.API_GENERAL));

  // Apply feature flag middleware
  app.use(createFeatureFlagMiddleware());

  // CSP reporting endpoint
  app.use('/api/csp', cspReportRouter);

  // Basic API endpoints
  app.get('/api/customers', jwtAuth, requireTenantAccess, async (req: AuthenticatedRequest, res: any) => {
    try {
      const customers = await storage.getCustomers(req.user!.tenantId!);
      res.json(customers);
    } catch (error) {
      console.error('Error fetching customers:', error);
      res.status(500).json({ message: 'Failed to fetch customers' });
    }
  });

  app.post('/api/customers', jwtAuth, requireTenantAccess, async (req: AuthenticatedRequest, res: any) => {
    try {
      const validatedData = insertCustomerSchema.parse(req.body);
      const customer = await storage.createCustomer(req.user!.tenantId!, validatedData);
      res.status(201).json(customer);
    } catch (error) {
      console.error('Error creating customer:', error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: 'Validation error', errors: error.errors });
      }
      res.status(500).json({ message: 'Failed to create customer' });
    }
  });

  app.get('/api/tickets', jwtAuth, requireTenantAccess, async (req: AuthenticatedRequest, res: any) => {
    try {
      const tickets = await storage.getTickets(req.user!.tenantId!);
      res.json(tickets);
    } catch (error) {
      console.error('Error fetching tickets:', error);
      res.status(500).json({ message: 'Failed to fetch tickets' });
    }
  });

  app.post('/api/tickets', jwtAuth, requireTenantAccess, async (req: AuthenticatedRequest, res: any) => {
    try {
      const validatedData = insertTicketSchema.parse(req.body);
      const ticket = await storage.createTicket(req.user!.tenantId!, validatedData);
      res.status(201).json(ticket);
    } catch (error) {
      console.error('Error creating ticket:', error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: 'Validation error', errors: error.errors });
      }
      res.status(500).json({ message: 'Failed to create ticket' });
    }
  });

  app.get('/api/users', jwtAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const users = await storage.getUser(1); // Temporary fix
      res.json(users);
    } catch (error) {
      console.error('Error fetching users:', error);
      res.status(500).json({ message: 'Failed to fetch users' });
    }
  });

  // Mount module routes
  app.use('/api/tickets/config', ticketConfigRoutes);
  app.use('/api/users', userManagementRoutes);
  app.use('/api/tenant-admin/teams', tenantAdminTeamRoutes);
  app.use('/api/integrity', integrityRoutes);
  app.use('/api/system', systemScanRoutes);
  app.use('/api/technical-skills', technicalSkillsRoutes);
  app.use('/api/internal-forms', internalFormsRoutes);
  app.use('/api/locations', locationRoutes);
  app.use('/api/tickets/relationships', ticketRelationshipsRoutes);
  app.use('/api/omni-bridge', omniBridgeRoutes);
  app.use('/api/saas-admin', saasAdminRoutes);
  app.use('/api/tenant-admin', tenantAdminRoutes);
  app.use('/api/dashboard', dashboardRoutes);
  app.use('/api/timecard', timecardRoutes);
  app.use('/api/schedule', scheduleRoutes);
  app.use('/api/schema-consolidation', schemaConsolidationRoutes);

  // Health check endpoint
  app.get('/api/health', (req, res) => {
    res.json({ 
      status: 'healthy', 
      timestamp: new Date().toISOString(),
      environment: process.env.NODE_ENV || 'development'
    });
  });

  // Create HTTP server
  const server = createServer(app);
  
  return server;
}